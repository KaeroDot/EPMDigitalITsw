"""A simple script to test resampling algorithms.

This script can generate input data, sample it, resample it, and plot it.
"""

import numpy as np
import numpy.typing as npt
import scipy.signal
import sympy
import time
import matplotlib.pyplot as plt
from scipy.signal import resample_poly
import matplotlib.pyplot as plt


class CubicSpline:
    """Cubic splines.

    Parameters
    ----------
    x : npt.ArrayLike
        X coordinates through which the splines should interpolate.
    y : npt.ArrayLike
        Y coordinates through which the splines should interpolate.

    Examples
    --------
    >>> import numpy as np
    >>> x_values = [0, 1, 2, 3, 4]
    >>> y_values = [0, 1, 4, 9, 16]

    >>> cubic_spline = CubicSpline(x_values, y_values)

    >>> x_eval = np.linspace(0, 4)
    >>> y_eval = cubic_spline.evaluate(x_eval)
    """

    def __init__(self, x: npt.ArrayLike, y: npt.ArrayLike) -> None:
        self.x = np.array(x)
        self.y = np.array(y)
        self.n = len(x)
        self.a, self.b, self.c, self.d = self._calculate_coefficients()

    def _calculate_coefficients(
        self
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """Calculate the coefficients at initialisation."""
        a = self.y.copy()
        b = [0.0] * self.n
        c = [0.0] * self.n
        d = [0.0] * self.n

        h = [self.x[i + 1] - self.x[i] for i in range(self.n - 1)]
        alpha = [
            (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1]) * (a[i] - a[i - 1])
            for i in range(1, self.n - 1)
        ]

        l = [1] * self.n
        mu = [0] * self.n
        z = [0] * self.n

        for i in range(1, self.n - 1):
            l[i] = 2 * (self.x[i + 1] - self.x[i - 1]) - h[i - 1] * mu[i - 1]
            mu[i] = h[i] / l[i]
            z[i] = (alpha[i - 1] - h[i - 1] * z[i - 1]) / l[i]

        for j in range(self.n - 2, -1, -1):
            c[j] = z[j] - mu[j] * c[j + 1]
            b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3
            d[j] = (c[j + 1] - c[j]) / (3 * h[j])

        return a, b, c, d

    def evaluate(self, x_eval: npt.ArrayLike) -> np.ndarray:
        """Evaluate the spline at given points.

        Parameters
        ----------
        x_eval : npt.ArrayLike
            X coordinates of evaluated points

        Returns
        -------
        np.ndarray
            Y coordinates of evaluated splines.
        """
        y_eval = np.zeros_like(x_eval)
        for i in range(self.n - 1):
            mask = np.logical_and(self.x[i] <= x_eval, x_eval <= self.x[i + 1])
            dx = x_eval - self.x[i]
            y_eval += mask * (
                self.a[i] + self.b[i] * dx + self.c[i] * dx**2 + self.d[i] * dx**3
            )
        return y_eval


def fft_dB(signal, ts):
    """Calculate FFT

    Parameters
    ----------
    signal : np.array
        Signal one dimensional array.
    ts : _type_
        Sampling frequency.

    Returns
    -------
    f : np.array
        FFT frequency scale
    M : np.array
        FFT peak amplitude in dB

    Note
    ----
    This function returns only real values of the FFT.
    """

    N = len(signal)
    N_2 = int(np.floor(N / 2))
    f_res = 1 / (N * ts)  # frequency resolution
    X = np.fft.rfft(signal)
    X = X[0:N_2] / (N / 2)  # scale FFT and take the first half
    M = 20 * np.log10(X)  # FFT peak amplitude in dB
    f = np.linspace(0, N_2 - 1, len(M)) * f_res  # FFT frequency scale

    return f.real, M.real


def resample_spline(signal, ts_orig, ts_new):
    """Resample the signal using splines.

    Parameters
    ----------
    signal : np.array
        The original signal.
    ts_orig : float
        The original sampling time.
    ts_new : float
        The new sampling time.

    Returns
    -------
    signal_new : np.array
        The resampled signal.

    Notes
    -----
    Algorithm provided by Rado Lapuh.
    """

    N = len(signal)
    s = np.arange(N) * ts_orig
    u = np.arange(N) * ts_new

    cubic_spline = CubicSpline(s, signal)
    signal_new = cubic_spline.evaluate(u)

    return signal_new


def resample_sinc_interp(signal, ts_orig, ts_new):
    """Resample the signal using sinc interpolation.

    Parameters
    ----------
    signal : np.array
        The original signal.
    ts_orig : float
        The original sampling time.
    ts_new : float
        The new sampling time.

    Returns
    -------
    signal_new : np.array
        The resampled signal.

    Notes
    -----
    Algorithm provided by Rado Lapuh.
    """

    N = len(signal)
    s = np.atleast_2d(np.arange(N) * ts_orig).T
    u = np.atleast_2d(np.arange(N) * ts_new).T

    sinc_M = np.tile(u, (1, len(s))) - np.tile(s.T, (len(u), 1))
    y = np.dot(np.sinc(sinc_M / ts_orig), signal)

    return y


def resample_resampy(
    signal,
    ts_orig,
    ts_new,
    num_zeros=64,
    precision=9,
    window=None,
    window_kwargs={},
    rolloff=0.945,
):
    """Resample the signal using band limited sinc interpolation.

    Parameters
    ----------
    signal : np.array
        The original signal.
    ts_orig : float
        The original sampling time.
    ts_new : float
        The new sampling time.
    num_zeros : int > 0, optional
        The number of zero-crossings to retain in the sinc filter.
    precision : int > 0, optional
        The number of filter coefficients to retain for each zero-crossing.
    window : callable, optional
        The window function. If None, uses ``np.hanning``.
        Check ``scipy.signal.get_window``.
    window_kwargs : dict
        Additional parameters supplied to the windowing function.
    rolloff : float > 0, optional
        The roll-off frequency (as a fraction of nyquist).

    Returns
    -------
    signal_new : np.array
        The resampled signal.

    Notes
    -----
    Method adapted from https://github.com/bmcfee/resampy. When checking the source, make
    sure to check ``resample_nu`` method, not ``resample``, which seems to not work
    properly.
    """

    def _sinc_window(
        num_zeros=64, precision=9, window=None, window_kwargs={}, rolloff=0.945
    ):
        """Construct a windowed sinc interpolation filter.

        Parameters
        ----------
        num_zeros : int > 0
            The number of zero-crossings to retain in the sinc filter.
        precision : int > 0
            The number of filter coefficients to retain for each zero-crossing.
        window : callable
            The window function. If None, uses ``np.hanning``.
            Check ``scipy.signal.get_window``.
        window_kwargs : dict
            Additional parameters supplied to the windowing function.
        rolloff : float > 0
            The roll-off frequency (as a fraction of nyquist).

        Returns
        -------
        interp_window: np.ndarray [shape=(num_zeros * num_table + 1)]
            The interpolation window (right-hand side).
        num_bits: int
            The number of bits of precision to use in the filter table.

        Raises
        ------
        TypeError
            If `window` is not callable.
        ValueError
            If `num_zeros < 1`, `precision < 1`, or `rolloff` is outside the range
            `(0, 1]`.
        """

        # Check inputs
        if window is None:
            window = np.hanning
        elif not callable(window):
            raise TypeError(f"window must be callable, not type(window)={type(window)}")
        if not 0 < rolloff <= 1:
            raise ValueError(f"Invalid roll-off: rolloff={rolloff}")
        if num_zeros < 1:
            raise ValueError(f"Invalid num_zeros: num_zeros={num_zeros}")
        if precision < 0:
            raise ValueError(f"Invalid precision: precision={precision}")

        # Generate the right-wing of the sinc
        num_bits = 2**precision
        n = num_bits * num_zeros
        sinc_win = rolloff * np.sinc(
            rolloff * np.linspace(0, num_zeros, num=n + 1, endpoint=True)
        )

        # Build the window function and cut off the left half
        taper = window(2 * n + 1, **window_kwargs)[n:]
        interp_win = taper * sinc_win

        return interp_win, num_bits

    def _resample(x, t_out, interp_win, interp_delta, num_table, scale):
        y = np.zeros_like(x)

        index_step = int(scale * num_table)
        time_register = 0.0

        n = 0
        frac = 0.0
        index_frac = 0.0
        offset = 0
        eta = 0.0
        weight = 0.0

        nwin = interp_win.shape[0]
        n_orig = x.shape[0]
        n_out = t_out.shape[0]

        for t in range(n_out):
            time_register = t_out[t]

            # Grab the top bits as an index to the input buffer
            n = int(time_register)

            # Grab the fractional component of the time index
            frac = scale * (time_register - n)

            # Offset into the filter
            index_frac = frac * num_table
            offset = int(index_frac)

            # Interpolation factor
            eta = index_frac - offset

            # Compute the left wing of the filter response
            i_max = min(n + 1, (nwin - offset) // index_step)
            for i in range(i_max):
                weight = (
                    interp_win[offset + i * index_step]
                    + eta * interp_delta[offset + i * index_step]
                )
                y[t] += weight * x[n - i]

            # Invert P
            frac = scale - frac

            # Offset into the filter
            index_frac = frac * num_table
            offset = int(index_frac)

            # Interpolation factor
            eta = index_frac - offset

            # Compute the right wing of the filter response
            k_max = min(n_orig - n - 1, (nwin - offset) // index_step)
            for k in range(k_max):
                weight = (
                    interp_win[offset + k * index_step]
                    + eta * interp_delta[offset + k * index_step]
                )
                y[t] += weight * x[n + k + 1]

        return y

    # Get filter data
    interp_win, precision = _sinc_window(
        num_zeros=num_zeros,
        precision=precision,
        window=window,
        window_kwargs=window_kwargs,
        rolloff=rolloff,
    )
    interp_delta = np.diff(interp_win, append=interp_win[-1])

    # Construct and normalize output time
    N = len(signal)
    t_out = np.linspace(0, (N - 1) * ts_new, N)
    t_out = t_out / ts_orig

    # Resample
    y = _resample(signal, t_out, interp_win, interp_delta, precision, 1.0)
    return y


def resample_fractional(signal, ts_orig, ts_new):
    """From CHAT-GPT, doesn't work."""

    # Design a low-pass FIR filter for bandlimited interpolation
    # You can customize the filter design by changing the taps and cutoff frequency.
    # Here we use a simple low-pass filter with 31 taps and cutoff frequency = 0.8.
    taps = 31
    cutoff = 0.8
    fir_filter = np.sinc(2 * cutoff * (np.arange(taps) - (taps - 1) / 2))

    # Normalize the filter to preserve the energy
    fir_filter /= np.sum(fir_filter)

    # Perform fractional resampling using scipy's resample_poly function
    resampling_factor = ts_new / ts_orig
    p, q = sympy.fraction(sympy.nsimplify(resampling_factor))
    print(int(p), int(q), float(p / q), resampling_factor)
    output_signal = resample_poly(signal, up=int(p), down=int(q), window=fir_filter)

    return output_signal


def generate_signal(f, N, ts, snr=np.inf):
    """Generate signal.

    Parameters
    ----------
    f : float
        Signal frequency in Hz.
    N : int
        Length of the signal.
    ts : float
        Sampling time in seconds.
    snr : float, optional
        Signal to noise ratio, by default infinite.

    Returns
    -------
    t : np.array
        A 1D array with time steps.
    signal : np.array
        A 1D array with signal at time steps.
    """

    t = np.linspace(0, (N - 1) * ts, N)
    signal = np.sin(2 * np.pi * f * t)

    if not np.isinf(snr):
        noise = 10 ** (-snr / 20)
        signal = signal + noise * np.random.normal(loc=0.0, scale=1.0, size=N)

    return t, signal


if __name__ == "__main__":
    t_0 = time.time()

    # Fixed parameters
    N = 2000  # number of points
    ts = 0.00025  # sampling time

    # Variable parameters
    f = 49.77  # frequency
    snr = np.inf  # signal to noise ratio in dB

    # Source signal
    t, signal = generate_signal(f, N, ts, snr)

    # FFT of the source signal
    f_0, s_0 = fft_dB(signal, ts)

    # Estimate signal frequency
    f_est = f

    # Resampling parameters
    cycles = int(np.floor(N * ts * f_est))  # number of full cycles available
    ts_new = cycles / f_est / N

    # p, q = sympy.fraction(sympy.nsimplify(1/ts_new, 1/ts, rational=True))
    # if p*q > 2e31:
    #     p = 1
    #     q = 1

    # Resample signal
    signal_resampled_0 = resample_sinc_interp(signal=signal, ts_orig=ts, ts_new=ts_new)
    signal_resampled_1 = resample_resampy(
        signal=signal,
        ts_orig=ts,
        ts_new=ts_new,
        num_zeros=20,
        precision=4,
        window=scipy.signal.windows.kaiser,
        window_kwargs={"beta": 100},
        rolloff=1,
    )
    signal_resampled_2 = resample_spline(signal=signal, ts_orig=ts, ts_new=ts_new)

    # num_zeros=20,
    # precision=4,
    # window=scipy.signal.windows.hann,
    # window=scipy.signal.windows.blackman,
    # window=scipy.signal.windows.flattop,
    # window=scipy.signal.windows.blackmanharris,
    # window=scipy.signal.windows.nuttall,
    # window=scipy.signal.windows.kaiser, window_kwargs={"beta":100}
    # window=scipy.signal.windows.gaussian, window_kwargs={"std":25}
    # window=scipy.signal.windows.dpss, window_kwargs={"NW": 10}
    # window=scipy.signal.windows.chebwin, window_kwargs={"NW": 500}

    # import sys
    # sys.exit()

    # FFT of the new signal
    f_1, s_1 = fft_dB(signal_resampled_0, ts_new)
    f_2, s_2 = fft_dB(signal_resampled_1, ts_new)
    f_3, s_3 = fft_dB(signal_resampled_2, ts_new)

    print(f"Time: {time.time() - t_0:.4f} seconds.")

    # Plot signal
    plt.plot(f_0, s_0, "k", label="original")
    plt.plot(f_1, s_1, "b", label="resample_sinc_interp")
    plt.plot(f_2, s_2, "r", label="resample_resampy")
    plt.plot(f_3, s_3, "g", label="resample_spline")
    plt.xlabel("frequency [Hz]")
    plt.ylabel("amplitude [dB]")
    # plt.xlim(0, N)
    # plt.ylim(-160, 0)
    plt.grid(True, linestyle="-", linewidth=0.5, color="lightgray")
    plt.legend()
    plt.tight_layout()

    plt.savefig("resample.png")
